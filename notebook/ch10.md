第十章 SCTP客戶/服務器程序例子
==========================

# 示例代碼中遇到的問題和解決辦法

在該章隨書示例中的`sctp/sctp_addr_to_associd.c`中的
`sctp_addr_to_associd`函數在當前的Linux和FreeBSD上都無法獲得
關聯ID，需改用`SCTP_GET_PEER_ADDR_INFO`套接字選項。改變之後的
代碼如下：

    sctp_assoc_t
    sctp_address_to_associd(int sock_fd, struct sockaddr *sa,
                            socklen_t salen)
    {
       struct sctp_paddrinfo sp;
       socklen_t siz;

       siz = sizeof(struct sctp_paddrinfo);
       bzero(&sp, siz);
       memcpy(&sp.spinfo_address, sa, salen);
       Sctp_opt_info(sock_fd, 0, SCTP_GET_PEER_ADDR_INFO,
                     &sp, &siz);
       return sp.spinfo_assoc_id;
    }


另外，如在第九章的筆記中所說，`sctp/sctpserv01.c`、
`sctp/sctp_strcli.c`、`sctp/sctp_strcliecho.c`中在調用
`sctp_sendmsg`函數時，都需要指定`msg_flags`的`MSG_NOTIFICATION`選項，
否則函數不會返回`sctp_sndrcvinfo`結構。

# 10.6

FreeBSD和Linux上的實現，系統默認的外出流默認值是10。如果客戶和服務器想要使用多於10個流時，書上說的是需要在把服務器程序改爲允許在關聯啟動階段增長端點請求的流數目，而且必須在關聯尚未建立時啟用。並給出了下面的示例代碼：

    --------------------------------- sctp/sctpserv02.c
    14    if (argc == 2)
    15        stream_increment = atoi(argv[1]);
    16    sock_fd = Socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP);
    17    bzero(&initm, sizeof(initm));
    18    initm.sinit_num_ostreams = SERV_MORE_STRMS_SCTP;
    19    Setsocket(sock_fd, IPPROTO_SCTP, SCTP_INITMSG, &initm, sizeof(initm));
    -------------------------------- sctp/sctpserve02.c

**附注：**

但是，在我當前的Linux和FreeBSD實現中，（我的Linux內核是4.0.4-ARCH，FreeBSD是10.1-Release，）這樣做都沒用，相反的，是要更改客戶端的外出流的請求數。也就是說上面一段代碼應該放在客戶端而非服務器端。
